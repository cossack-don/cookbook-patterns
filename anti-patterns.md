# Список Анти-Паттернов программирования 

1. Spaghetti Code (Спагетти-код)
__Описание__: Код, в котором отсутствует чёткая структура, а логика программы запутана и сложна для понимания.

__Проблема__: Трудно поддерживать, расширять и отлаживать.

__Решение__: Использование модульности, разделение на функции/классы, следование принципам SOLID.

---
2. God Object (Божественный объект)
__Описание__: Класс или объект, который знает и делает слишком много, нарушая принцип единственной ответственности.

__Проблема__: Сложность тестирования, изменения и повторного использования.

__Решение__: Разделение на более мелкие и специализированные компоненты.

---
3. Copy-Paste Programming (Копипаст-программирование)
__Описание__: Дублирование кода вместо создания универсальных функций или модулей.

__Проблема__: Увеличение количества ошибок, сложность внесения изменений.

__Решение__: Рефакторинг, выделение общей логики в функции или классы.

---
4. Premature Optimization (Преждевременная оптимизация)
__Описание__: Оптимизация кода до того, как это действительно необходимо, часто в ущерб читаемости и поддерживаемости.

__Проблема__: Усложнение кода без реальной необходимости.

__Решение__: Оптимизировать только после выявления узких мест с помощью профилирования.

---
5. Magic Numbers/Strings (Магические числа/строки)
__Описание__: Использование чисел или строк напрямую в коде без объяснения их значения.

__Проблема__: Снижение читаемости и увеличение вероятности ошибок.

__Решение__: Использование констант или перечислений (enum).

---
6. Hardcoding (Жёсткое кодирование)
__Описание__: Встраивание данных или конфигураций непосредственно в код.

__Проблема__: Сложность изменения параметров без перекомпиляции.

__Решение__: Использование конфигурационных файлов или переменных окружения.

---
7. Cargo Cult Programming (Программирование по шаблону)
__Описание__: Слепое копирование кода или практик без понимания их назначения.

__Проблема__: Неэффективное использование ресурсов и неоптимальные решения.

__Решение__: Понимание принципов и контекста перед применением.

---
8. Reinventing the Wheel (Изобретение велосипеда)
__Описание__: Создание собственных решений для задач, которые уже имеют проверенные и оптимизированные реализации.

Проблема: Потеря времени и увеличение вероятности ошибок.

__Решение__: Использование существующих библиотек и фреймворков.

---
9. Golden Hammer (Золотой молоток)
__Описание__: Использование одного и того же инструмента или технологии для всех задач, даже если они не подходят.

__Проблема__: Неоптимальные решения и увеличение сложности.

__Решение__: Выбор подходящих инструментов для каждой задачи.

---
10. Boat Anchor (Якорь)
__Описание__: Хранение в коде неиспользуемых или устаревших компонентов.

__Проблема__: Увеличение сложности и объёма кода.

__Решение__: Регулярный рефакторинг и удаление ненужного кода.

---
11. Lava Flow (Лавовый поток)
__Описание__: Сохранение устаревшего или непонятного кода, потому что "он работает".

__Проблема__: Накопление технического долга.

__Решение__: Рефакторинг и документирование кода.

---
12. Poltergeist (Полтергейст)
__Описание__: Классы или объекты, которые существуют только для передачи данных между другими объектами.

__Проблема__: Усложнение архитектуры.

__Решение__: Упрощение взаимодействия между объектами.

---
13. Circular Dependency (Циклическая зависимость)
__Описание__: Взаимная зависимость между модулями или классами, когда они ссылаются друг на друга.

__Проблема__: Сложность тестирования и поддержки.

__Решение__: Реорганизация кода для устранения циклов.

---
14. Shotgun Surgery (Выстрел дробью)
__Описание__: Внесение множества мелких изменений в разные части кода для реализации одной функциональности.

__Проблема__: Увеличение риска ошибок и сложность отслеживания изменений.

__Решение__: Концентрация логики в одном месте.

---
15. Feature Envy (Зависть к функциональности)
__Описание__: Метод одного класса чрезмерно использует данные или методы другого класса.

__Проблема__: Нарушение инкапсуляции.

__Решение__: Перемещение метода в тот класс, данные которого он использует.

---
16. Yo-Yo Problem (Проблема йо-йо)
__Описание__: Слишком глубокая иерархия наследования, из-за которой сложно понять, где реализована конкретная функциональность.

__Проблема__: Сложность понимания и отладки.

__Решение__: Использование композиции вместо наследования.

---
17. Singleton Abuse (Злоупотребление синглтоном)
__Описание__: Чрезмерное использование паттерна Singleton, что приводит к глобальному состоянию и проблемам с тестированием.

__Проблема__: Усложнение тестирования и поддержки.

__Решение__: Использование Dependency Injection и других подходов.

---
18. Tight Coupling (Жёсткая связность)
__Описание__: Сильная зависимость между модулями или классами, что делает их негибкими.

__Проблема__: Сложность изменения и тестирования.

__Решение__: Использование слабой связности и интерфейсов.

---
19. Not Invented Here (Не изобретено здесь)
__Описание__: Отказ от использования существующих решений в пользу собственных, даже если они хуже.

__Проблема__: Потеря времени и снижение качества.

__Решение__: Использование проверенных сторонних решений.

---
20. Optimistic Locking (Оптимистичная блокировка)
__Описание__: Игнорирование проблем параллелизма, что может привести к состоянию гонки.

__Проблема__: Ошибки в многопоточной среде.

__Решение__: Использование механизмов синхронизации.

---
21. Analysis Paralysis (Аналитический паралич)
__Описание__: Чрезмерное увлечение анализом и проектированием, что задерживает разработку.

__Проблема__: Задержка выпуска продукта.

__Решение__: Итеративная разработка и MVP (Minimum Viable Product).

---
22. Fear of Adding Classes (Страх добавления классов)
__Описание__: Нежелание создавать новые классы, что приводит к увеличению размера существующих.

__Проблема__: Нарушение принципа единственной ответственности.

__Решение__: Создание новых классов для разделения ответственности.

---
23. Inner-Platform Effect (Эффект внутренней платформы)
__Описание__: Создание собственной сложной системы, которая дублирует функциональность существующей платформы.

__Проблема__: Увеличение сложности и затрат.

__Решение__: Использование стандартных решений.

---
24. Interface Bloat (Раздувание интерфейса)
__Описание__: Добавление слишком большого количества методов в интерфейс, что делает его сложным для реализации.

__Проблема__: Нарушение принципа разделения интерфейса (ISP).

__Решение__: Разделение интерфейсов на более мелкие.

---
25. Overengineering (Излишнее усложнение)
__Описание__: Создание сложных решений для простых задач.

__Проблема__: Увеличение времени разработки и сложности поддержки.

__Решение__: Использование простых решений, когда это возможно.
